namespace Game.Terrain.Old;

using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Runtime.InteropServices;
using System.Threading.Tasks;
using Godot;
using static Game.Terrain.Old.ChunkDataGPU;

// Class to handle generating, loading/unloading ChunkGPUs
public partial class ChunkManagerGPU : Node3D
{
    [Export]
    PackedScene chunkTemplate;

    [Export]
    SimpleRigidPlayer player;

    [Export]
    Node3D terraformMarker;

    // Manage the current chunks
    readonly Dictionary<ChunkID, ChunkGPU> loadedChunks = [];
    readonly Queue<ChunkID> chunksToReload = new(); // If it doesn't exist, load it, otherwise reload
    readonly HashSet<ChunkID> queuedChunkIDs = [];

    readonly Queue<ChunkGPU> freeChunks = new(); // For object pooling

    // Minimum time before triggering a queue, so it doesnt happen too often at ChunkGPU borders
    const int MIN_QUEUE_INTERVAL = 100; //ms
    ulong lastQueueMs = Time.GetTicksMsec();

    ChunkID currentPlayerChunk = new();
    const float CHUNK_UNLOAD_DIST = 4f;

    // ChunkGPU generation
    // We'll have to clear this after some limit and on area changes
    readonly Dictionary<ChunkID, byte[]> knownChunkMods = [];

    // This is the task tracking whether we already are processing a chunk
    bool currentlyComputing;

    // Index of the bufferset for the shader
    const int BUFFER_SET_INDEX = 0;

    // Bind Indices
    const int TRIANGLE_BIND_INDEX = 0;
    const int PARAMS_BIND_INDEX = 1;
    const int COUNTER_BIND_INDEX = 2;
    const int LUT_BIND_INDEX = 3;
    const int MODDATA_BIND_INDEX = 4;

    // Compute shader path
    const string SHADER_PATH = "res://scripts/terrain/ChunkGenerator.glsl";

    RenderingDevice renderDevice;

    // Resource IDs
    Rid shader;
    Rid pipeline;
    Rid bufferSet;
    Rid triangleBuffer;
    Rid paramsBuffer;
    Rid counterBuffer;
    Rid lutBuffer;
    Rid modBuffer;

    // Buffer data
    byte[] counterDataBytes = new byte[sizeof(uint)];
    byte[] chunkParamBytes = new byte[Marshal.SizeOf<ChunkParameters>()];

    void InitializeCompute()
    {
        renderDevice = RenderingServer.CreateLocalRenderingDevice();
        var shaderFile = GD.Load<RDShaderFile>(SHADER_PATH);
        var shaderBytecode = shaderFile.GetSpirV();
        var shader = renderDevice.ShaderCreateFromSpirV(shaderBytecode);

        // Make triangle buffer
        GD.Print("MAX_TRIANGLE_BYTES ", TerrainData.MAX_TRIANGLE_BYTES);
        // eeesh this is a lot of bytes

        // Make our storage buffers (this one for triangles)
        triangleBuffer = InitStorageBuffer(
            out var trianglesUniform,
            TerrainData.MAX_TRIANGLE_BYTES,
            TRIANGLE_BIND_INDEX
        );

        // Buffer for our adjustable parameters
        UpdateChunkParams(new ChunkID(0, 0, 0), false);

        paramsBuffer = InitStorageBuffer(
            out var paramsUniform,
            (uint)chunkParamBytes.Length,
            PARAMS_BIND_INDEX,
            chunkParamBytes
        );

        // So much boilerplate.... :(
        // Make a buffer for a counter (?)
        ResetTriangleCounter();
        counterBuffer = InitStorageBuffer(
            out var counterUniform,
            (uint)counterDataBytes.Length,
            COUNTER_BIND_INDEX,
            counterDataBytes
        );

        // make our marching cubes LUT table buffer (shouldn't need to touch this later)
        var lutBytes = new byte[MarchingCubeTables.LUT.Length * sizeof(int)];
        Buffer.BlockCopy(MarchingCubeTables.LUT, 0, lutBytes, 0, lutBytes.Length);

        lutBuffer = InitStorageBuffer(
            out var lutUniform,
            (uint)lutBytes.Length,
            LUT_BIND_INDEX,
            lutBytes
        );

        modBuffer = InitStorageBuffer(
            out var modUniform,
            (uint)TerrainData.MAX_MOD_BYTES,
            MODDATA_BIND_INDEX
        );

        bufferSet = renderDevice.UniformSetCreate(
            [trianglesUniform, paramsUniform, counterUniform, lutUniform, modUniform],
            shader,
            BUFFER_SET_INDEX
        );

        pipeline = renderDevice.ComputePipelineCreate(shader);
    }

    void UpdateChunkParams(ChunkID cID, bool useMods)
    {
        ref var chunkParams = ref MemoryMarshal.AsRef<ChunkParameters>(chunkParamBytes);
        chunkParams.noiseScale = 1.0f;
        chunkParams.isoLevel = 0.00f;
        chunkParams.numVoxelsPerAxis = TerrainData.VOXELS_PER_AXIS;
        chunkParams.chunkScale = TerrainData.CHUNK_SIZE;
        chunkParams.chunkX = cID.posX;
        chunkParams.chunkY = cID.posY;
        chunkParams.chunkZ = cID.posZ;
        chunkParams.noiseOffsetX = 0;
        chunkParams.noiseOffsetY = 0;
        chunkParams.noiseOffsetZ = 0;

        // Why not a boolean? this is just an easy optimization that avoids
        // an if-statement on the GPU. (multiply by 0 -> no effect)
        // Plus if needed, I can make this a float later and adjust how
        // much of the modifications show up (shouldn't be needed though)
        if (useMods)
        {
            chunkParams.useMods = 1;
        }
        else
        {
            chunkParams.useMods = 0;
        }
    }

    void ResetTriangleCounter()
    {
        var counter = new uint[] { 0 };
        Buffer.BlockCopy(counter, 0, counterDataBytes, 0, counterDataBytes.Length);
    }

    // Helper function to auto setup a storage buffer
    Rid InitStorageBuffer(out RDUniform uniform, uint size, int bindIndex, byte[] data = null)
    {
        var newBuffer = renderDevice.StorageBufferCreate(size, data);
        var newUniform = new RDUniform
        {
            UniformType = RenderingDevice.UniformType.StorageBuffer,
            Binding = bindIndex
        };
        newUniform.AddId(newBuffer);
        uniform = newUniform;
        return newBuffer;
    }

    // Helper to queue up a chunk
    public void QueueChunk(ChunkID chunkID)
    {
        chunksToReload.Enqueue(chunkID);
        queuedChunkIDs.Add(chunkID);
    }

    // For when we receive some ChunkGPU mods from the server
    public void ApplyChunkMods(ChunkID chunkID, byte[] chunkMods)
    {
        // GD.Print(chunkID);
        knownChunkMods[chunkID] = chunkMods;
        if (loadedChunks.ContainsKey(chunkID))
        {
            QueueChunk(chunkID);
        }
    }

    // Simple helper to start reloading the next chunk
    void ReloadNextChunk()
    {
        _ = ReloadChunk(chunksToReload.Dequeue());
    }

    Task ReloadChunk(ChunkID chunkID)
    {
        currentlyComputing = true;
        // If this ChunkGPU is already loaded, reload it
        // Otherwise grab a new one and move it where it needs to go
        if (!loadedChunks.TryGetValue(chunkID, out ChunkGPU chunkToLoad))
        {
            chunkToLoad = GetNewChunk();
            loadedChunks[chunkID] = chunkToLoad;
        }

        return Task.Run(() => ComputeChunk(chunkID, chunkToLoad));
    }

    // This method should run in a Task
    void ComputeChunk(ChunkID cID, ChunkGPU c)
    {
        c.CurrentChunkID = cID;
        var useMods = knownChunkMods.ContainsKey(cID);
        // First let's update our buffers
        UpdateChunkParams(cID, useMods);
        ResetTriangleCounter();

        renderDevice.BufferUpdate(paramsBuffer, 0, (uint)chunkParamBytes.Length, chunkParamBytes);
        renderDevice.BufferUpdate(
            counterBuffer,
            0,
            (uint)counterDataBytes.Length,
            counterDataBytes
        );

        if (useMods)
        {
            var modData = knownChunkMods[cID];
            renderDevice.BufferUpdate(modBuffer, 0, (uint)modData.Length, modData);
        }

        // Now that they're updated, let's start the compute
        var computeList = renderDevice.ComputeListBegin();
        renderDevice.ComputeListBindComputePipeline(computeList, pipeline);
        renderDevice.ComputeListBindUniformSet(computeList, bufferSet, BUFFER_SET_INDEX);
        renderDevice.ComputeListDispatch(
            computeList,
            TerrainData.TERRAIN_RESOLUTION,
            TerrainData.TERRAIN_RESOLUTION,
            TerrainData.TERRAIN_RESOLUTION
        );
        renderDevice.ComputeListEnd();

        // Submit it and wait (should be fine since we're in an async task/thread thing)
        renderDevice.Submit();
        renderDevice.Sync();

        // Get our data back
        counterDataBytes = renderDevice.BufferGetData(counterBuffer);
        uint count = MemoryMarshal.Cast<byte, uint>(counterDataBytes)[0];

        // Only get the number of triangles that actually exist
        var triangleDataBytes = renderDevice.BufferGetData(
            triangleBuffer,
            0,
            TerrainData.BYTES_PER_TRI * count
        );

        Span<Triangle> triangles = MemoryMarshal.Cast<byte, Triangle>(triangleDataBytes);

        // Chuck the data over to the new ChunkGPU and let it finish processing
        c.ProcessChunk(triangles, count);

        // It's fine if it returns false, that just means the chunkID
        // was (re)loaded manually instead of being in the queue
        queuedChunkIDs.Remove(cID);

        currentlyComputing = false;
    }

    // Grab an available new chunk
    ChunkGPU GetNewChunk()
    {
        if (freeChunks.Count > 0)
        {
            return freeChunks.Dequeue();
        }
        // Otherwise instantiate a new one
        return InstantiateChunk();
    }

    // Manually instantiate a new chunk
    ChunkGPU InstantiateChunk()
    {
        var newChunk = chunkTemplate.Instantiate<ChunkGPU>();
        AddChild(newChunk);
        return newChunk;
    }

    void TryUnloadChunk(ChunkID cID)
    {
        if (loadedChunks.Remove(cID, out var removedChunk))
        {
            removedChunk.HibernateChunk();
            freeChunks.Enqueue(removedChunk);
        }
        // Otherwise can't unload it if it's not loaded :V
    }

    // Called when the node enters the scene tree for the first time.
    public override void _Ready()
    {
        // Manager.Instance.MainWorld.chunkManager = this;

        InitializeCompute();

        // // make an initial pool of ChunkGPU nodes
        // const int PoolChunks = 400;
        // for (int x = 0; x < PoolChunks; x++)
        // {
        //     var c = InstantiateChunk();
        //     freeChunks.Enqueue(c);
        // }
        // GD.Print("pool ", freeChunks.Count);

        QueueChunk(new(0, 2, 0));
        // QueueChunk(new(0, 2, 1));
        QueuePlayerChunks();
        GD.Print("Max Mod Bytes ", TerrainData.MAX_MOD_BYTES);
    }

    void QueuePlayerChunks()
    {
        // make the loop bigger by one to remove the outermost ChunkGPU IDs
        const int GenerateDistance = TerrainData.CHUNK_VIEW_DIST;

        for (int x = -GenerateDistance; x <= GenerateDistance; x++)
        {
            for (int y = -GenerateDistance; y <= GenerateDistance; y++)
            {
                for (int z = -GenerateDistance; z <= GenerateDistance; z++)
                {
                    ChunkID toQueue =
                        new(
                            x + currentPlayerChunk.posX,
                            y + currentPlayerChunk.posY,
                            z + currentPlayerChunk.posZ
                        );

                    bool chunkIsLoaded = loadedChunks.ContainsKey(toQueue);
                    bool chunkIsQueued = queuedChunkIDs.Contains(toQueue);
                    if (!chunkIsLoaded && !chunkIsQueued)
                    {
                        // Queue only if the ChunkGPU is not there and it's not already queued
                        QueueChunk(toQueue);
                        // GD.Print("Queueing ", toQueue);
                    }
                }
            }
        }

        // Unload far chunks
        const float SquareUnloadDist = CHUNK_UNLOAD_DIST * CHUNK_UNLOAD_DIST;
        var playerPos = currentPlayerChunk.GetSampleVector();

        foreach (ChunkID cID in loadedChunks.Keys)
        {
            if (playerPos.DistanceSquaredTo(cID.GetSampleVector()) >= SquareUnloadDist)
            {
                TryUnloadChunk(cID);
            }
        }
    }

    public override void _PhysicsProcess(double delta)
    {
        // GD.Print("loaded ", loadedChunks.Count);
        // GD.Print("free ", freeChunks.Count);
        // GD.Print("queued ", queuedChunkIDs.Count);
        var newPlayerChunk = ChunkID.GetNearestID(player.Position);

        if (currentPlayerChunk != newPlayerChunk)
        {
            // Update our current chunk
            currentPlayerChunk = newPlayerChunk;

            if ((Time.GetTicksMsec() - lastQueueMs) >= MIN_QUEUE_INTERVAL)
            {
                QueuePlayerChunks();

                // the timer is so we don't trigger a ton of reloads
                // when near the edge of two chunks. Shouldn't cause a problem
                // because we already ensure the current player chunk is loaded.
                lastQueueMs = Time.GetTicksMsec();
            }
        }
    }

    // Called every frame. 'delta' is the elapsed time since the previous frame.
    public override void _Process(double delta)
    {
        // See if there's something to reload, and make sure there isn't a chunk computing already
        if ((chunksToReload.Count > 0) && (!currentlyComputing))
        {
            if (!loadedChunks.ContainsKey(currentPlayerChunk))
            {
                // wait for this chunk because we at least
                // need the chunk the player is in to be loaded
                ReloadChunk(currentPlayerChunk).Wait();
            }
            else
            {
                ReloadNextChunk();
            }
        }

        // if (Input.IsActionJustPressed(GameActions.PLAYER_ROLL_RIGHT))
        // {
        //     var readableMods = MemoryMarshal.Cast<byte, float>(funnyMods);
        //     for (int idx = 0; idx < readableMods.Length; idx++)
        //     {
        //         const int numVoxels = TerrainParams.NUM_VOXELS_PER_AXIS;
        //         var zQuotient = Math.DivRem(idx, numVoxels, out var zPos);
        //         var yQuotient = Math.DivRem(zQuotient, numVoxels, out var yPos);
        //         var xPos = yQuotient % numVoxels;
        //         var calcPos = new Vector3(xPos, yPos, zPos);
        //         if (
        //             xPos > 0
        //             && xPos < numVoxels
        //             && yPos > 0
        //             && yPos < numVoxels
        //             && zPos > 0
        //             && zPos < numVoxels
        //         )
        //         {
        //             readableMods[idx] = 20; // * (xPos / numVoxels);
        //         }
        //     }
        //     ApplyChunkMods(currentPlayerChunk, funnyMods);
        // }
    }

    static int GetPointID(Vector3 pointPosition)
    {
        const int lengthArrayPerAxis = TerrainData.LENGTH_MOD_ARRAY_PER_AXIS;

        pointPosition += new Vector3(1, 1, 1);

        // The ones are to leave space for normal vertices
        return Mathf.RoundToInt(
            (pointPosition.Z * lengthArrayPerAxis * lengthArrayPerAxis)
                + (pointPosition.Y * lengthArrayPerAxis)
                + pointPosition.X
        );
    }

    public void TerraformPoint(Vector3 worldPoint, float strength)
    {
        terraformMarker.Position = worldPoint;

        var closestChunk = ChunkID.GetNearestID(worldPoint);
        // GD.Print("closest ", closestChunk);
        for (int x = -1; x <= 1; x++)
        {
            for (int y = -1; y <= 1; y++)
            {
                for (int z = -1; z <= 1; z++)
                {
                    ChunkID currentChunkID =
                        new(closestChunk.posX + x, closestChunk.posY + y, closestChunk.posZ + z);

                    var chunkWorldPos = currentChunkID.GetSampleVector() * TerrainData.CHUNK_SIZE;
                    var localTerraformPos = (worldPoint - chunkWorldPos) / TerrainData.CHUNK_SIZE;

                    // Now the terraform pos is from 0 to 1
                    localTerraformPos += new Vector3(0.5f, 0.5f, 0.5f);

                    // Scale it to the number of sample points
                    localTerraformPos *= TerrainData.NUM_VOXELS_PER_AXIS;

                    localTerraformPos = localTerraformPos.Round();

                    // If this point isn't in range, ignore it
                    bool validPosition = true;
                    for (int coord = 0; coord < 3; coord++)
                    {
                        if (localTerraformPos[coord] < -1)
                        {
                            validPosition = false;
                        }
                        if (localTerraformPos[coord] > TerrainData.NUM_VOXELS_PER_AXIS + 1)
                        {
                            validPosition = false;
                        }
                    }

                    if (!validPosition)
                    {
                        continue;
                    }

                    // GD.Print(localTerraformPos, " local ", currentChunkID);

                    // Either get the existing mod array or make a new one
                    if (!knownChunkMods.TryGetValue(currentChunkID, out var chunkMods))
                    {
                        chunkMods = new byte[TerrainData.MAX_MOD_BYTES];
                    }

                    var chunkModData = MemoryMarshal.Cast<byte, float>(chunkMods);

                    int modIndex = GetPointID(localTerraformPos);
                    // GD.Print(modIndex);

                    if (modIndex >= 0 && modIndex < chunkModData.Length)
                    {
                        chunkModData[modIndex] -= strength;
                    }

                    ApplyChunkMods(currentChunkID, chunkMods);
                }
            }
        }
    }

    public override void _Notification(int what)
    {
        if (what == NotificationPredelete)
        {
            ReleaseData();
        }
    }

    // I don't know if this is necessary, but it does say to free RIDs
    // when you're done with them in the docs.
    void ReleaseData()
    {
        renderDevice.FreeRid(pipeline);
        renderDevice.FreeRid(triangleBuffer);
        renderDevice.FreeRid(paramsBuffer);
        renderDevice.FreeRid(counterBuffer);
        renderDevice.FreeRid(lutBuffer);
        renderDevice.FreeRid(shader);
        renderDevice.Free();
        renderDevice = null;
    }
}
